;buildInfoPackage: chisel3, version: 3.1.8, scalaVersion: 2.11.12, sbtVersion: 1.1.1, builtAtString: 2019-07-08 17:44:42.884, builtAtMillis: 1562607882884
circuit AXISAndLenStream : 
  module ElasticBufferRegExportAXISAndLenStream : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, regs : {valid : UInt<1>, bits : UInt<2>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<2>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<2>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module ElasticBufferRegExportAXISAndLenStream_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, regs : {valid : UInt<1>, bits : UInt<2>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<2>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<2>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream_1 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream_1 @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module ElasticBufferRegExportAXISAndLenStream_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, regs : {valid : UInt<1>, bits : UInt<32>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<32>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<32>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream_2 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream_2 @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module ElasticBufferRegExportAXISAndLenStream_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}, regs : {valid : UInt<1>, bits : UInt<4>}[2], readyReg : UInt<1>}
    
    reg outerRegData : UInt<4>, clock @[AXISAndLenStream.scala 34:27]
    reg outerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 35:32]
    reg innerRegData : UInt<4>, clock @[AXISAndLenStream.scala 36:27]
    reg innerRegValid : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 37:32]
    reg readyReg : UInt<1>, clock @[AXISAndLenStream.scala 38:23]
    node _T_39 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 40:19]
    when _T_39 : @[AXISAndLenStream.scala 41:5]
      outerRegData <= io.in.bits @[AXISAndLenStream.scala 42:22]
      innerRegData <= outerRegData @[AXISAndLenStream.scala 43:22]
      outerRegValid <= io.in.valid @[AXISAndLenStream.scala 44:23]
      node _T_40 = not(io.out.valid) @[AXISAndLenStream.scala 45:59]
      node _T_41 = or(io.out.ready, _T_40) @[AXISAndLenStream.scala 45:57]
      node _T_42 = not(_T_41) @[AXISAndLenStream.scala 45:42]
      node _T_43 = and(outerRegValid, _T_42) @[AXISAndLenStream.scala 45:40]
      innerRegValid <= _T_43 @[AXISAndLenStream.scala 45:23]
      skip @[AXISAndLenStream.scala 41:5]
    node _T_45 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 47:33]
    node _T_46 = mux(_T_45, outerRegData, innerRegData) @[AXISAndLenStream.scala 47:23]
    io.out.bits <= _T_46 @[AXISAndLenStream.scala 47:17]
    node _T_48 = eq(readyReg, UInt<1>("h01")) @[AXISAndLenStream.scala 48:34]
    node _T_49 = mux(_T_48, outerRegValid, innerRegValid) @[AXISAndLenStream.scala 48:24]
    io.out.valid <= _T_49 @[AXISAndLenStream.scala 48:18]
    node _T_50 = not(io.out.valid) @[AXISAndLenStream.scala 49:32]
    node _T_51 = or(io.out.ready, _T_50) @[AXISAndLenStream.scala 49:30]
    readyReg <= _T_51 @[AXISAndLenStream.scala 49:14]
    io.in.ready <= readyReg @[AXISAndLenStream.scala 50:17]
    io.regs[0].bits <= outerRegData @[AXISAndLenStream.scala 51:21]
    io.regs[0].valid <= outerRegValid @[AXISAndLenStream.scala 52:22]
    io.regs[1].bits <= innerRegData @[AXISAndLenStream.scala 53:21]
    io.regs[1].valid <= innerRegValid @[AXISAndLenStream.scala 54:22]
    io.readyReg <= readyReg @[AXISAndLenStream.scala 55:17]
    
  module ElasticBufferAXISAndLenStream_3 : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip in : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}, out : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}}
    
    inst fullBuffer of ElasticBufferRegExportAXISAndLenStream_3 @[AXISAndLenStream.scala 21:28]
    fullBuffer.clock <= clock
    fullBuffer.reset <= reset
    fullBuffer.io.in.bits <= io.in.bits @[AXISAndLenStream.scala 22:22]
    fullBuffer.io.in.valid <= io.in.valid @[AXISAndLenStream.scala 22:22]
    io.in.ready <= fullBuffer.io.in.ready @[AXISAndLenStream.scala 22:22]
    io.out.bits <= fullBuffer.io.out.bits @[AXISAndLenStream.scala 23:12]
    io.out.valid <= fullBuffer.io.out.valid @[AXISAndLenStream.scala 23:12]
    fullBuffer.io.out.ready <= io.out.ready @[AXISAndLenStream.scala 23:12]
    
  module AXISAndLenStream : 
    input clock : Clock
    input reset : UInt<1>
    output io : {flip rdAddr : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, rdData : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, flip wrAddr : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<2>}, flip wrData : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, wrAck : UInt<1>, offset : {valid : UInt<1>, bits : UInt<32>}, nnz : {valid : UInt<1>, bits : UInt<32>}, outputSize : {valid : UInt<1>, bits : UInt<32>}, running : UInt<1>, flip done : UInt<1>, flip rowPtrStream : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, lenStream : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<32>}, flip wstrb : {flip ready : UInt<1>, valid : UInt<1>, bits : UInt<4>}}
    
    reg state : UInt<1>, clock with : (reset => (reset, UInt<1>("h00"))) @[AXISAndLenStream.scala 80:24]
    node _T_96 = eq(state, UInt<1>("h01")) @[AXISAndLenStream.scala 81:25]
    io.running <= _T_96 @[AXISAndLenStream.scala 81:16]
    reg regs : UInt<32>[3], clock @[AXISAndLenStream.scala 83:19]
    wire start : UInt<1> @[AXISAndLenStream.scala 84:21]
    inst ElasticBufferAXISAndLenStream of ElasticBufferAXISAndLenStream @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream.clock <= clock
    ElasticBufferAXISAndLenStream.reset <= reset
    ElasticBufferAXISAndLenStream.io.in.bits <= io.rdAddr.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream.io.in.valid <= io.rdAddr.valid @[AXISAndLenStream.scala 9:17]
    io.rdAddr.ready <= ElasticBufferAXISAndLenStream.io.in.ready @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream.io.out.ready <= io.rdData.ready @[AXISAndLenStream.scala 87:20]
    node _T_107 = eq(state, UInt<1>("h00")) @[AXISAndLenStream.scala 88:54]
    node _T_111 = eq(UInt<2>("h03"), ElasticBufferAXISAndLenStream.io.out.bits) @[Mux.scala 46:19]
    node _T_112 = mux(_T_111, regs[2], _T_107) @[Mux.scala 46:16]
    node _T_113 = eq(UInt<2>("h02"), ElasticBufferAXISAndLenStream.io.out.bits) @[Mux.scala 46:19]
    node _T_114 = mux(_T_113, regs[1], _T_112) @[Mux.scala 46:16]
    node _T_115 = eq(UInt<1>("h01"), ElasticBufferAXISAndLenStream.io.out.bits) @[Mux.scala 46:19]
    node _T_116 = mux(_T_115, regs[0], _T_114) @[Mux.scala 46:16]
    io.rdData.bits <= _T_116 @[AXISAndLenStream.scala 88:20]
    io.rdData.valid <= ElasticBufferAXISAndLenStream.io.out.valid @[AXISAndLenStream.scala 89:21]
    inst ElasticBufferAXISAndLenStream_1 of ElasticBufferAXISAndLenStream_1 @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream_1.clock <= clock
    ElasticBufferAXISAndLenStream_1.reset <= reset
    ElasticBufferAXISAndLenStream_1.io.in.bits <= io.wrAddr.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream_1.io.in.valid <= io.wrAddr.valid @[AXISAndLenStream.scala 9:17]
    io.wrAddr.ready <= ElasticBufferAXISAndLenStream_1.io.in.ready @[AXISAndLenStream.scala 9:17]
    inst ElasticBufferAXISAndLenStream_2 of ElasticBufferAXISAndLenStream_2 @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream_2.clock <= clock
    ElasticBufferAXISAndLenStream_2.reset <= reset
    ElasticBufferAXISAndLenStream_2.io.in.bits <= io.wrData.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream_2.io.in.valid <= io.wrData.valid @[AXISAndLenStream.scala 9:17]
    io.wrData.ready <= ElasticBufferAXISAndLenStream_2.io.in.ready @[AXISAndLenStream.scala 9:17]
    inst ElasticBufferAXISAndLenStream_3 of ElasticBufferAXISAndLenStream_3 @[AXISAndLenStream.scala 8:23]
    ElasticBufferAXISAndLenStream_3.clock <= clock
    ElasticBufferAXISAndLenStream_3.reset <= reset
    ElasticBufferAXISAndLenStream_3.io.in.bits <= io.wstrb.bits @[AXISAndLenStream.scala 9:17]
    ElasticBufferAXISAndLenStream_3.io.in.valid <= io.wstrb.valid @[AXISAndLenStream.scala 9:17]
    io.wstrb.ready <= ElasticBufferAXISAndLenStream_3.io.in.ready @[AXISAndLenStream.scala 9:17]
    node _T_120 = and(ElasticBufferAXISAndLenStream_1.io.out.valid, ElasticBufferAXISAndLenStream_2.io.out.valid) @[AXISAndLenStream.scala 94:46]
    node wrAddrDataAvailable = and(_T_120, ElasticBufferAXISAndLenStream_3.io.out.valid) @[AXISAndLenStream.scala 94:63]
    ElasticBufferAXISAndLenStream_1.io.out.ready <= ElasticBufferAXISAndLenStream_2.io.out.valid @[AXISAndLenStream.scala 95:20]
    ElasticBufferAXISAndLenStream_2.io.out.ready <= ElasticBufferAXISAndLenStream_1.io.out.valid @[AXISAndLenStream.scala 96:20]
    ElasticBufferAXISAndLenStream_3.io.out.ready <= ElasticBufferAXISAndLenStream_1.io.out.valid @[AXISAndLenStream.scala 97:19]
    start <= UInt<1>("h00") @[AXISAndLenStream.scala 99:11]
    io.wrAck <= UInt<1>("h00") @[AXISAndLenStream.scala 100:14]
    when wrAddrDataAvailable : @[AXISAndLenStream.scala 101:31]
      node _T_124 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<1>("h00")) @[AXISAndLenStream.scala 102:26]
      node _T_125 = not(ElasticBufferAXISAndLenStream_3.io.out.bits) @[AXISAndLenStream.scala 102:50]
      node _T_127 = eq(_T_125, UInt<1>("h00")) @[AXISAndLenStream.scala 102:50]
      node _T_128 = and(_T_124, _T_127) @[AXISAndLenStream.scala 102:34]
      when _T_128 : @[AXISAndLenStream.scala 102:56]
        node _T_129 = bits(ElasticBufferAXISAndLenStream_2.io.out.bits, 0, 0) @[AXISAndLenStream.scala 103:27]
        node _T_131 = eq(_T_129, UInt<1>("h01")) @[AXISAndLenStream.scala 103:31]
        when _T_131 : @[AXISAndLenStream.scala 103:40]
          start <= UInt<1>("h01") @[AXISAndLenStream.scala 104:17]
          skip @[AXISAndLenStream.scala 103:40]
        skip @[AXISAndLenStream.scala 102:56]
      io.wrAck <= UInt<1>("h01") @[AXISAndLenStream.scala 107:16]
      skip @[AXISAndLenStream.scala 101:31]
    node _T_135 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<1>("h01")) @[AXISAndLenStream.scala 111:49]
    node _T_136 = and(wrAddrDataAvailable, _T_135) @[AXISAndLenStream.scala 111:32]
    node _T_137 = not(ElasticBufferAXISAndLenStream_3.io.out.bits) @[AXISAndLenStream.scala 111:73]
    node _T_139 = eq(_T_137, UInt<1>("h00")) @[AXISAndLenStream.scala 111:73]
    node _T_140 = and(_T_136, _T_139) @[AXISAndLenStream.scala 111:58]
    when _T_140 : @[AXISAndLenStream.scala 111:79]
      regs[0] <= ElasticBufferAXISAndLenStream_2.io.out.bits @[AXISAndLenStream.scala 112:19]
      skip @[AXISAndLenStream.scala 111:79]
    node _T_142 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<2>("h02")) @[AXISAndLenStream.scala 111:49]
    node _T_143 = and(wrAddrDataAvailable, _T_142) @[AXISAndLenStream.scala 111:32]
    node _T_144 = not(ElasticBufferAXISAndLenStream_3.io.out.bits) @[AXISAndLenStream.scala 111:73]
    node _T_146 = eq(_T_144, UInt<1>("h00")) @[AXISAndLenStream.scala 111:73]
    node _T_147 = and(_T_143, _T_146) @[AXISAndLenStream.scala 111:58]
    when _T_147 : @[AXISAndLenStream.scala 111:79]
      regs[1] <= ElasticBufferAXISAndLenStream_2.io.out.bits @[AXISAndLenStream.scala 112:19]
      skip @[AXISAndLenStream.scala 111:79]
    node _T_149 = eq(ElasticBufferAXISAndLenStream_1.io.out.bits, UInt<2>("h03")) @[AXISAndLenStream.scala 111:49]
    node _T_150 = and(wrAddrDataAvailable, _T_149) @[AXISAndLenStream.scala 111:32]
    node _T_151 = not(ElasticBufferAXISAndLenStream_3.io.out.bits) @[AXISAndLenStream.scala 111:73]
    node _T_153 = eq(_T_151, UInt<1>("h00")) @[AXISAndLenStream.scala 111:73]
    node _T_154 = and(_T_150, _T_153) @[AXISAndLenStream.scala 111:58]
    when _T_154 : @[AXISAndLenStream.scala 111:79]
      regs[2] <= ElasticBufferAXISAndLenStream_2.io.out.bits @[AXISAndLenStream.scala 112:19]
      skip @[AXISAndLenStream.scala 111:79]
    io.nnz.bits <= regs[0] @[AXISAndLenStream.scala 116:24]
    io.outputSize.bits <= regs[1] @[AXISAndLenStream.scala 117:24]
    io.offset.bits <= regs[2] @[AXISAndLenStream.scala 118:24]
    io.running <= UInt<1>("h00") @[AXISAndLenStream.scala 120:16]
    io.offset.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 121:21]
    io.nnz.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 122:18]
    io.outputSize.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 123:25]
    node _T_159 = eq(UInt<1>("h00"), state) @[Conditional.scala 37:30]
    when _T_159 : @[Conditional.scala 40:58]
      when start : @[AXISAndLenStream.scala 127:21]
        state <= UInt<1>("h01") @[AXISAndLenStream.scala 128:17]
        io.offset.valid <= UInt<1>("h01") @[AXISAndLenStream.scala 129:27]
        io.nnz.valid <= UInt<1>("h01") @[AXISAndLenStream.scala 130:24]
        io.outputSize.valid <= UInt<1>("h01") @[AXISAndLenStream.scala 131:31]
        skip @[AXISAndLenStream.scala 127:21]
      skip @[Conditional.scala 40:58]
    else : @[Conditional.scala 39:67]
      node _T_163 = eq(UInt<1>("h01"), state) @[Conditional.scala 37:30]
      when _T_163 : @[Conditional.scala 39:67]
        io.running <= UInt<1>("h01") @[AXISAndLenStream.scala 135:20]
        when io.done : @[AXISAndLenStream.scala 136:23]
          state <= UInt<1>("h00") @[AXISAndLenStream.scala 137:17]
          skip @[AXISAndLenStream.scala 136:23]
        skip @[Conditional.scala 39:67]
    wire emptyData : {valid : UInt<1>, bits : UInt<32>} @[AXISAndLenStream.scala 142:25]
    emptyData.valid <= UInt<1>("h00") @[AXISAndLenStream.scala 143:21]
    emptyData.bits is invalid @[AXISAndLenStream.scala 144:21]
    wire _T_177 : {valid : UInt<1>, bits : UInt<32>}[2] @[AXISAndLenStream.scala 145:36]
    _T_177[0].bits <= emptyData.bits @[AXISAndLenStream.scala 145:36]
    _T_177[0].valid <= emptyData.valid @[AXISAndLenStream.scala 145:36]
    _T_177[1].bits <= emptyData.bits @[AXISAndLenStream.scala 145:36]
    _T_177[1].valid <= emptyData.valid @[AXISAndLenStream.scala 145:36]
    reg delayedRowPtr : {valid : UInt<1>, bits : UInt<32>}[2], clock with : (reset => (reset, _T_177)) @[AXISAndLenStream.scala 145:32]
    node _T_227 = not(delayedRowPtr[0].valid) @[AXISAndLenStream.scala 148:51]
    node _T_228 = or(io.lenStream.ready, _T_227) @[AXISAndLenStream.scala 148:49]
    node _T_229 = not(delayedRowPtr[1].valid) @[AXISAndLenStream.scala 148:77]
    node _T_230 = or(_T_228, _T_229) @[AXISAndLenStream.scala 148:75]
    io.rowPtrStream.ready <= _T_230 @[AXISAndLenStream.scala 148:27]
    when io.done : @[AXISAndLenStream.scala 149:19]
      delayedRowPtr[0].valid <= UInt<1>("h00") @[AXISAndLenStream.scala 150:30]
      skip @[AXISAndLenStream.scala 149:19]
    else : @[AXISAndLenStream.scala 151:89]
      node _T_232 = not(delayedRowPtr[0].valid) @[AXISAndLenStream.scala 151:38]
      node _T_233 = or(io.lenStream.ready, _T_232) @[AXISAndLenStream.scala 151:36]
      node _T_234 = not(delayedRowPtr[1].valid) @[AXISAndLenStream.scala 151:64]
      node _T_235 = or(_T_233, _T_234) @[AXISAndLenStream.scala 151:62]
      when _T_235 : @[AXISAndLenStream.scala 151:89]
        delayedRowPtr[0].bits <= io.rowPtrStream.bits @[AXISAndLenStream.scala 152:29]
        delayedRowPtr[0].valid <= io.rowPtrStream.valid @[AXISAndLenStream.scala 153:30]
        skip @[AXISAndLenStream.scala 151:89]
    when io.done : @[AXISAndLenStream.scala 155:19]
      delayedRowPtr[1].valid <= UInt<1>("h00") @[AXISAndLenStream.scala 156:30]
      skip @[AXISAndLenStream.scala 155:19]
    else : @[AXISAndLenStream.scala 157:63]
      node _T_237 = not(delayedRowPtr[1].valid) @[AXISAndLenStream.scala 157:38]
      node _T_238 = or(io.lenStream.ready, _T_237) @[AXISAndLenStream.scala 157:36]
      when _T_238 : @[AXISAndLenStream.scala 157:63]
        delayedRowPtr[1].bits <= delayedRowPtr[0].bits @[AXISAndLenStream.scala 158:24]
        delayedRowPtr[1].valid <= delayedRowPtr[0].valid @[AXISAndLenStream.scala 158:24]
        skip @[AXISAndLenStream.scala 157:63]
    node _T_239 = and(delayedRowPtr[1].valid, delayedRowPtr[0].valid) @[AXISAndLenStream.scala 160:50]
    io.lenStream.valid <= _T_239 @[AXISAndLenStream.scala 160:24]
    node _T_240 = sub(delayedRowPtr[0].bits, delayedRowPtr[1].bits) @[AXISAndLenStream.scala 161:49]
    node _T_241 = asUInt(_T_240) @[AXISAndLenStream.scala 161:49]
    node _T_242 = tail(_T_241, 1) @[AXISAndLenStream.scala 161:49]
    io.lenStream.bits <= _T_242 @[AXISAndLenStream.scala 161:24]
    
